/*
processImage.js
(C) Callum Baird, 2018

A script which fetches the map generated by the Google Static Maps API and processes it to determine the area of road in the selection.

Libraries used:
Google Static Maps, Google 2018 - https://developers.google.com/maps/documentation/maps-static/intro
Node.js, Node.js Foundation 2018 - https://nodejs.org/en/
Socket.io (via npm), Socket.io Team 2018 - https://socket.io/

*/

var url = ""; // url of the Google Static Map (generated in scripts/map.js)
var edgeLengthPx = 0; // size of one side of the selected area in px
var edgeLengthKm = 0; // size of one side of the selected area in km
var pixelAreaKm; // area of one px in square kilometers
var imageSizePx; // size of the image in px
var croppedPx; // number of pixels cropped from original google map image

var roadPx = 0; // area of the road in px
var roadKm = 0; // area of the road in km

var socket = io.connect('localhost:8080'); // connect to the open socket


/* Main script
* Listens for the button click event from socket to initiate
* Fetches the image from google static maps link and loads it into the web page
* Iterates over the pixels of the image to crop uneccessary pixels and then determine the number of pixels which are roads
* Calculates and formats the output information
*/

// Listen for the Socket message for the button being pressed
// Data contained is the URL and selected square kilometer size from the user input
socket.on('btnClick', function(data){ // when the UI button click message has been received

    url = data.URL; // get the URL passed in the message
    edgeLengthKm = data.size; // get the user selected size from message

    pixelAreaKm = 0; // reset output

    if(edgeLengthKm<5){ // images come in 2 standard sizes after beind cropped depending on the size of area selected (266px square or 333px square)
        edgeLengthPx = 266;
        imageSizePx = 266*266;
    }else{
        edgeLengthPx = 333;
        imageSizePx = 333*333;
    }

    pixelAreaKm = edgeLengthKm/imageSizePx; // calculate area of one pixel in km2

    // Display of outputs
    // Image object is created and initialised
    // Upon loading of the new image, processing starts
    var canvas = document.getElementById("outputMap"); // HTML UI element where image output will be displayed
    var context = canvas.getContext("2d"); // context for drawing the canvas content

    var img = new Image; // image object
    img.crossOrigin = "Anonymous"; // prevent security error
    img.src = url; // fill the image with the one generated by the Google Static Maps URL, triggers img.onload event above 

    
    // Image onload listener
    // Runs when image has been loaded into the canvas (line 58)
    img.onload = function(){
        context.canvas.width = img.width; // set canvas width to contain the full image
        context.canvas.height = img.height;// set canvas height to contain the full image        

        context.drawImage(img,0,0,img.width,img.height); // fill the canvas with the image

        var imgData = context.getImageData(0,0,context.canvas.width,context.canvas.height); // get the image data object
        imgData = cropImage(imgData); // update image data with new cropped pic
        context.putImageData(imgData,0,0); // update the image data in the context

        roadPx = imageSizePx - getNonRoadPx(imgData.data);  // get amount of pixels containing road by subtracting cropped pixels and non road pixels from total
        
        roadKm =  roadPx * pixelAreaKm; // road area is number of road pixels times the area of 1 pixel

        if(roadKm < edgeLengthKm*edgeLengthKm*0.005 && edgeLengthKm > 1){ // adjust output to zero if within the margin of error
            roadKm = 0;
        }else if(roadKm < edgeLengthKm*edgeLengthKm*0.015){
            roadKm = 0;
        }

        // display output in HTML document
        var areaText = document.getElementById("outputText1"); // get output UI text element
        if(roadKm < 1){ // if the size is smaller than 1km2, represent in m2
            areaText.innerHTML = String(Math.round(roadKm*10000000)/100) + "m<sup>2</sup>"; // round to m2 with 2dp
        }else{
            areaText.innerHTML = String(Math.round(roadKm*100)/100) + "km<sup>2</sup>"; // round to km2 with 2dp
        }          
    };
});


/* cropImage()
* Removes any greyscale pixels from an image by setting them to transparent
* Since google maps is drawing a blue square for user input, any non covered pixels are greyscale and can be removed
*
* takes the input of an image data object (data stored in a HTML canvas context)
* returns an updated image data object with white and black pixels removed
*/
function cropImage(imageData){
    pixelArray = imageData.data; // get the array of pixels stored in the image data [r1,g1,b1,t1,r2,g2,b2,t2,.....,rn,gn,bn,tn]

    for(var i=0; i<pixelArray.length; i+=4){ // iterate over all pixels in the array
        if(pixelArray[i] == pixelArray[i+1] && pixelArray[i] == pixelArray[i+2]){ // if a pixel has equal r,g and b it is greyscale
                pixelArray[i+3] = 0; // set to transparent
        }
    }
    var newImgData = imageData; // create a new imgData object out of existing to maintain size etc.
    newImgData.data = pixelArray; // update the data
    return(newImgData);
}


/* getNonRoadPx()
* Iterates over a list of pixels to determine how many pixels are not part of the road
* If a pixel has (r,g,b) of (38,45,124) then it is dark blue -> space between roads
*
* take the input of an array of pixel data [r1,g1,b1,t1,r2,g2,b2,t2,.....,rn,gn,bn,tn]
* returns the number of pixels with (r,g,b) == (38,45,124) 
*/
function getNonRoadPx(pixelData){
    pixelArray = pixelData;
    pxCount = 0;
    for(var i=0; i<pixelArray.length; i+=4){
        if(pixelArray[i] == 38 && pixelArray[i+1] == 45 && pixelArray[i+2] == 124){
            pxCount +=1;           
        }
    }
    return(pxCount);
}